use ast::{ WireValue, WireWidth };
use salad::{ BopCode, Simple, Test, Unreplaced, CoolProperty, MatchType };

grammar;

Repeat<delim, T>: Vec<T> = {
	<v:(<T> delim)*> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

Semicolons<T>: Vec<T> = Repeat<";", T>;
Commas<T>: Vec<T> = Repeat<",", T>;

BopCode : BopCode =
	{ "+"  => BopCode::Add
	, "-"  => BopCode::Sub
	, "*"  => BopCode::Mul
	, "/"  => BopCode::Div
	, "|"  => BopCode::Or
	, "^"  => BopCode::Xor
	, "&"  => BopCode::And
	, "==" => BopCode::Equal
	, "!=" => BopCode::NotEqual
	, "<=" => BopCode::LessEqual
	, ">=" => BopCode::GreaterEqual
	, "<"  => BopCode::Less
	, ">"  => BopCode::Greater
	, "&&" => BopCode::LogicalAnd
	, "||" => BopCode::LogicalOr
	, "<<" => BopCode::LeftShift
	, ">>" => BopCode::RightShift
	, ".." => BopCode::Concat
	}

Num : u128 =
	{ <s:r"0b[01_]+"> => s[2..].chars().filter_map(|x| x.to_digit(2)) // 0b should always be 2 bytes
		.rev().enumerate().map(|(i, x)| (x as u128) << i)
		.fold(0, |a, b| a + b)
	, <s:r"[0-9]+"> => s.parse().unwrap()
	}

VarName : String = <s : r"[A-Za-z_][A-Za-z_0-9]*"> => s.to_string();

TestName : String =
	{ <name : VarName> => name
	, <s : r#""[^\{\}]+"#> => s[1..].trim().to_string() // " should be 1 byte
	}

CoolProperty : CoolProperty =
	{ "Oneof" "(" <ls : Commas<Num>> ")" => CoolProperty::OneOf(ls)
	, "Neq" "(" <s : Simple> ")" => CoolProperty::Neq(s.rc())
	}

pub Test : Test =
	{ <name : TestName> "{" <ts : Semicolons<Test>> "}" => Test::Test(name, ts)
	, "Given" <l : Simple> "is" <r : Simple> => Test::Given(l.rc(), r.rc())
	, "Value" <name : VarName> <ps : Commas<CoolProperty>> => Test::ValueDef(name, ps)
	, <l : Simple> "<-" <r : Simple> => Test::Condition(l.rc(), r.rc())
	, "Match" "Regread" <a : VarName> <b : VarName> => Test::Match(MatchType::Regread(a, b))
	, "Match" "Regwrite" <a : VarName> <b : VarName> => Test::Match(MatchType::Regwrite(a, b))
	, "Match" "Any" <l : Simple> "<-" <r : Simple> => Test::Match(MatchType::Any(l.rc(), r.rc()))
	}

pub Simple : Simple =
	{ <l : NotBin> <op : BopCode> <r : Simple> => Simple::BinMaths(op, l.rc(), r.rc())
	, <s : NotBin> => s
	}

NotBin : Simple =
	{ <num : Num> => Simple::Literal(WireValue { bits: num, width: WireWidth::Unlimited })
	, "0w" <w : Num> ":" <n : Num> => Simple::Literal(WireValue { bits: n, width: WireWidth::Bits(w as u8) })
	, "[" <n:r"[0-9]+"> <x : Simple> "]" =>
		{ let num : u32 = n.parse().unwrap()
		; (0..num).fold(x, |x, _| Simple::Aged(x.rc()))
		}
	, "(" <s : Simple> ")" => s
	, <name : VarName> => Simple::Name(name)
	, "???" => Simple::Wildcard
	, "#"       <s : VarName> => Simple::Unreplaced(Unreplaced::Value(s))
	, "$input"  <s : VarName> => Simple::Unreplaced(Unreplaced::Input(s))
	, "$output" <s : VarName> => Simple::Unreplaced(Unreplaced::Output(s))
	, "$dst"    <s : VarName> => Simple::Unreplaced(Unreplaced::Dst(s))
	, "$src"    <s : VarName> => Simple::Unreplaced(Unreplaced::Src(s))
	, "@in:"    <s : VarName> => Simple::Unreplaced(Unreplaced::RegIn(s))
	, "@out:"   <s : VarName> => Simple::Unreplaced(Unreplaced::RegOut(s))
	, <x : NotBin> "[" <lo : Num> ".." <hi : Num> "]" => Simple::Slice(x.rc(), lo as u8, hi as u8)
	}
